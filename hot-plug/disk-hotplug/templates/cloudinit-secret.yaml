apiVersion: v1
kind: Secret
metadata:
  name: {{.name}}-cloudinit-{{.Replica}}
  namespace: {{.NAMESPACE}}
type: Opaque
stringData:
  userdata: |
    #cloud-config
    user: cloud-user
    password: redhat
    chpasswd: { expire: False }
    users:
      - name: cloud-user
        groups: sudo
        shell: /bin/bash
        sudo: ["ALL=(ALL) NOPASSWD:ALL"]
        lock_passwd: false
        passwd: "$6$rounds=4096$saltsalt$LBJKUk4Rtxd6TJmLvJOqN5I5vZ5JvQPTkYkWq6uQqmVzC1KvBP5EbHvJqBOw5t8f1PvLCT5VqZ5F1O5Q5ZJqN/"
    
    chpasswd:
      expire: false
    
    runcmd:
      # Install tools for disk management
      - yum install -y lshw lsblk parted xfsprogs

      # Create the script to monitor and mount hot-plugged disks
      - |
        cat > /usr/local/bin/mount-hotplug-disks.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "$(date): Starting disk mount script..."
        
        # Counter file to track sequential disk assignments
        COUNTER_FILE="/var/lib/mount-hotplug-counter"
        mkdir -p "$(dirname "$COUNTER_FILE")"
        
        # Initialize counter if it doesn't exist
        if [ ! -f "$COUNTER_FILE" ]; then
          echo "0" > "$COUNTER_FILE"
        fi
        
        # This loop iterates over devices that are not the root disk (sda/vda)
        # and are not already mounted. It handles both sd* and vd* device names (single and multi-letter).
        for dev_path in $(ls /dev/sd[b-z] /dev/sd[a-z][a-z] /dev/vd[b-z] /dev/vd[a-z][a-z] 2>/dev/null | sort -V); do
          if ! [ -b "$dev_path" ]; then
            echo "Skipping non-block device: $dev_path"
            continue
          fi
          
          # Define the partition device name (e.g., /dev/sdb1)
          part="${dev_path}1"
          
          # Check if this partition is already mounted
          if findmnt -S "$part" >/dev/null 2>&1; then
             echo "Partition $part is already mounted. Skipping."
             continue
          fi
          
          # Check if device is already mounted (before partitioning)
          if findmnt -S "$dev_path" >/dev/null 2>&1; then
             echo "Device $dev_path is already mounted. Skipping."
             continue
          fi

          echo "Processing disk: $dev_path"
          
          # Create a GPT partition table and one partition spanning the whole disk
          # This is idempotent; parted will exit with an error if the label already exists, which `|| true` handles.
          sudo parted -s "$dev_path" mklabel gpt mkpart primary xfs 0% 100% 2>&1 | grep -v "^Warning" || true
          sleep 2
          sudo partprobe "$dev_path" 2>&1 || true
          
          # Wait for the partition to be created
          for i in {1..5}; do [ -b "$part" ] && break; sleep 1; done
          if ! [ -b "$part" ]; then
            echo "ERROR: Partition $part did not appear. Skipping."
            continue
          fi
          
          # Format with XFS only if it doesn't already have a filesystem
          # Check if filesystem exists by trying to get TYPE attribute
          fs_type=$(sudo blkid -s TYPE -o value "$part" 2>/dev/null || echo "")
          if [ -z "$fs_type" ]; then
              echo "Formatting $part with XFS..."
              sudo mkfs.xfs -f "$part" >/dev/null 2>&1
              # Wait for filesystem to be recognized
              sleep 2
          else
              echo "Filesystem $fs_type already exists on $part"
          fi
          
          # Get UUID for fstab - retry a few times if needed
          uuid=""
          for retry in {1..5}; do
            uuid=$(sudo blkid -s UUID -o value "$part" 2>/dev/null || echo "")
            [ -n "$uuid" ] && break
            sleep 1
          done
          
          if [ -z "$uuid" ]; then
            echo "ERROR: Failed to get UUID for $part after formatting"
            continue
          fi
          
          # Check if UUID is already in fstab (means we already processed this disk)
          if grep -q "UUID=$uuid" /etc/fstab 2>/dev/null; then
            echo "UUID=$uuid already in /etc/fstab, getting mount point..."
            # Get the existing mount point from fstab
            mount_point=$(grep "UUID=$uuid" /etc/fstab | awk '{print $2}')
            echo "Mount point: $mount_point"
            # Ensure it's mounted
            if ! mountpoint -q "$mount_point" 2>/dev/null; then
              echo "Mounting existing entry..."
              sudo mount "$mount_point" 2>&1 || echo "WARNING: Failed to mount $mount_point"
            fi
            continue
          fi
          
          # Get next sequential disk number
          disk_num=$(($(cat "$COUNTER_FILE") + 1))
          echo "$disk_num" > "$COUNTER_FILE"
          
          # Create sequential mount point (e.g., /mnt/disk1, /mnt/disk2)
          mount_point="/mnt/disk${disk_num}"
          echo "Assigning mount point: $mount_point"
          mkdir -p "$mount_point"
          
          # Add to fstab
          echo "Adding UUID=$uuid to /etc/fstab at $mount_point"
          echo "UUID=$uuid $mount_point xfs defaults,nofail 0 2" >> /etc/fstab
          
          # Mount the filesystem
          echo "Mounting $mount_point..."
          if sudo mount "$mount_point" 2>&1; then
            echo "Successfully mounted $mount_point"
          else
            echo "ERROR: Failed to mount $mount_point"
            # Remove from fstab on failure
            sudo sed -i "\|UUID=$uuid|d" /etc/fstab
            # Decrement counter
            echo "$((disk_num - 1))" > "$COUNTER_FILE"
          fi
        done
        
        echo "$(date): Disk mounting process completed."
        echo "Final disk status:"
        lsblk
        echo ""
        echo "Mounted filesystems:"
        df -h | grep -E '(Filesystem|/mnt/disk)'
        EOF

      # Make the script executable
      - sudo chmod +x /usr/local/bin/mount-hotplug-disks.sh

      # Create a systemd service to run the script
      - |
        cat > /etc/systemd/system/mount-hotplug.service << EOF
        [Unit]
        Description=Mounts newly hot-plugged disks
                
        [Service]
        Type=oneshot
        ExecStart=/bin/bash /usr/local/bin/mount-hotplug-disks.sh
        TimeoutStartSec=300
        RemainAfterExit=false
        EOF
      
      # Create a systemd timer for delayed execution
      - |
        cat > /etc/systemd/system/mount-hotplug.timer << EOF
        [Unit]
        Description=Delayed timer for hot-plug disk mounting

        [Timer]
        # Run 5 seconds after this timer is started by the udev rule
        OnActiveSec=5s
        Unit=mount-hotplug.service
        EOF
      
      # Create udev rule to trigger timer on disk hotplug
      - |
        cat > /etc/udev/rules.d/85-mount-hotplug.rules << EOF
        # When a new block device (not vda/sda) is added, start the mount-hotplug timer
        ACTION=="add", SUBSYSTEM=="block", KERNEL=="[sv]d[b-z]", ENV{DEVTYPE}=="disk", RUN+="/bin/systemctl start mount-hotplug.timer"
        EOF
      
      # Enable and configure the service
      - sudo systemctl daemon-reload
      - sudo udevadm control --reload
      - sudo systemctl enable mount-hotplug.timer